// Generated by IcedCoffeeScript 1.7.1-c
(function() {
  var BigInteger, Curve, H, OIDS, OID_LOOKUP, SRF, SlicerBuffer, base, bn, iced, k, nist_p256, nist_p384, nist_p521, uint_to_buffer, v, __iced_k, __iced_k_noop,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-runtime').iced;
  __iced_k = __iced_k_noop = function() {};

  BigInteger = require('../bn').BigInteger;

  base = require('keybase-ecurve');

  uint_to_buffer = require('../util').uint_to_buffer;

  SlicerBuffer = require('../openpgp/buffer').SlicerBuffer;

  SRF = require('../rand').SRF;

  bn = require('../bn');

  exports.H = H = function(x) {
    return BigInteger.fromHex(x.split(/\s+/).join(''));
  };

  exports.Curve = Curve = (function(_super) {
    __extends(Curve, _super);

    function Curve(_arg) {
      var Gx, Gy, a, b, h, n, p;
      p = _arg.p, a = _arg.a, b = _arg.b, Gx = _arg.Gx, Gy = _arg.Gy, n = _arg.n, h = _arg.h, this.oid = _arg.oid;
      h || (h = BigInteger.ONE);
      Curve.__super__.constructor.call(this, p, a, b, Gx, Gy, n, h);
    }

    Curve.prototype.mkpoint = function(_arg) {
      var x, y;
      x = _arg.x, y = _arg.y;
      return base.Point.fromAffine(this, x, y);
    };

    Curve.prototype.nbits = function() {
      return this.p.bitLength();
    };

    Curve.prototype.mpi_bit_size = function() {
      return 2 * this.mpi_coord_bit_size() + 3;
    };

    Curve.prototype.mpi_coord_byte_size = function() {
      return Math.ceil(this.nbits() / 8);
    };

    Curve.prototype.mpi_coord_bit_size = function() {
      return this.mpi_coord_byte_size() * 8;
    };

    Curve.prototype._mpi_point_from_slicer_buffer = function(sb) {
      var b, n_bits, n_bytes, point, x, y, _ref;
      n_bits = sb.read_uint16();
      if (n_bits !== (b = this.mpi_bit_size())) {
        throw new Error("Need " + b + " bits for this curve; got " + n_bits);
      }
      if (sb.read_uint8() !== 0x4) {
        throw new Error("Can only handle 0x4 prefix for MPI representations");
      }
      n_bytes = this.mpi_coord_byte_size();
      _ref = [BigInteger.fromBuffer(sb.read_buffer(n_bytes)), BigInteger.fromBuffer(sb.read_buffer(n_bytes))], x = _ref[0], y = _ref[1];
      point = this.mkpoint({
        x: x,
        y: y
      });
      if (!this.isOnCurve(point)) {
        throw new Error("Given ECC point isn't on the given curve; data corruption detected.");
      }
      return [null, point];
    };

    Curve.prototype.mpi_point_from_buffer = function(b) {
      return this.mpi_point_from_slicer_buffer(new SlicerBuffer(b));
    };

    Curve.prototype.mpi_point_from_slicer_buffer = function(sb) {
      var e, err, point, _ref;
      err = point = null;
      try {
        _ref = this._mpi_point_from_slicer_buffer(sb), err = _ref[0], point = _ref[1];
      } catch (_error) {
        e = _error;
        err = e;
      }
      return [err, point];
    };

    Curve.prototype.point_to_mpi_buffer_compact = function(p) {
      return p.affineX.toBuffer(this.p.byteLength());
    };

    Curve.prototype.point_to_mpi_buffer = function(p) {
      var ret, sz;
      sz = this.mpi_coord_byte_size();
      ret = Buffer.concat([uint_to_buffer(16, this.mpi_bit_size()), new Buffer([0x4]), p.affineX.toBuffer(sz), p.affineY.toBuffer(sz)]);
      return ret;
    };

    Curve.prototype.random_scalar = function(cb) {
      var k, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/max/src/keybase/kbpgp/src/ecc/curves.iced",
            funcname: "Curve.random_scalar"
          });
          SRF().random_zn(_this.n.subtract(bn.nbv(2)), __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return k = arguments[0];
              };
            })(),
            lineno: 97
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          k = k.add(bn.BigInteger.ONE);
          return cb(k);
        };
      })(this));
    };

    return Curve;

  })(base.Curve);

  exports.nist_p256 = nist_p256 = function() {
    var Gx, Gy, a, b, n, p;
    p = H("FFFFFFFF 00000001 00000000 00000000 00000000 FFFFFFFF FFFFFFFF FFFFFFFF");
    a = H("FFFFFFFF 00000001 00000000 00000000 00000000 FFFFFFFF FFFFFFFF FFFFFFFC");
    b = H("5AC635D8 AA3A93E7 B3EBBD55 769886BC 651D06B0 CC53B0F6 3BCE3C3E 27D2604B");
    n = H("FFFFFFFF 00000000 FFFFFFFF FFFFFFFF BCE6FAAD A7179E84 F3B9CAC2 FC632551");
    Gx = H("6B17D1F2 E12C4247 F8BCE6E5 63A440F2 77037D81 2DEB33A0 F4A13945 D898C296");
    Gy = H("4FE342E2 FE1A7F9B 8EE7EB4A 7C0F9E16 2BCE3357 6B315ECE CBB64068 37BF51F5");
    return new Curve({
      p: p,
      a: a,
      b: b,
      Gx: Gx,
      Gy: Gy,
      n: n,
      oid: OIDS.nist_p256
    });
  };

  exports.nist_p384 = nist_p384 = function() {
    var Gx, Gy, a, b, n, p;
    p = H('ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff');
    a = H('ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc');
    b = H('b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef');
    n = H('ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973');
    Gx = H('aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7');
    Gy = H('3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f');
    return new Curve({
      p: p,
      a: a,
      b: b,
      Gx: Gx,
      Gy: Gy,
      n: n,
      oid: OIDS.nist_p384
    });
  };

  exports.nist_p521 = nist_p521 = function() {
    var Gx, Gy, a, b, n, p;
    p = H('000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff');
    a = H('000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc');
    b = H('00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00');
    n = H('000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409');
    Gx = H('000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66');
    Gy = H('00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650');
    return new Curve({
      p: p,
      a: a,
      b: b,
      Gx: Gx,
      Gy: Gy,
      n: n,
      oid: OIDS.nist_p521
    });
  };

  OIDS = {
    nist_p256: new Buffer([0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07]),
    nist_p384: new Buffer([0x2b, 0x81, 0x04, 0x00, 0x22]),
    nist_p521: new Buffer([0x2b, 0x81, 0x04, 0x00, 0x23])
  };

  OID_LOOKUP = {};

  for (k in OIDS) {
    v = OIDS[k];
    OID_LOOKUP[v.toString('hex')] = exports[k];
  }

  exports.alloc_by_oid = function(oid) {
    var curve, err, f;
    if (Buffer.isBuffer(oid)) {
      oid = oid.toString('hex');
    }
    err = curve = null;
    if ((f = OID_LOOKUP[oid.toLowerCase()]) != null) {
      curve = f();
    } else {
      err = new Error("Unknown curve OID: " + oid);
    }
    return [err, curve];
  };

  exports.alloc_by_nbits = function(nbits) {
    var err, f, ret;
    ret = err = null;
    nbits || (nbits = 256);
    f = (function() {
      switch (nbits) {
        case 256:
          return nist_p256;
        case 384:
          return nist_p384;
        case 521:
          return nist_p521;
        default:
          return null;
      }
    })();
    if (f != null) {
      ret = f();
    } else {
      err = new Error("No curve for " + nbits + " bits");
    }
    return [err, ret];
  };

}).call(this);
